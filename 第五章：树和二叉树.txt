数据的逻辑结构：1.线性结构  2.非线性结构（树、图）

树的定义：递归定义 （树结构有一个根结点，根节点下的元素又可以是子树）

树的表示：嵌套集合、广义表、凹入式

树的基本术语：任意一个结点至多一个直接前驱（只有根节点没有直接前驱），任意结点可以有若干后继。
	结点的度：结点拥有的子树数
	分支结点（非终端结点）、内部结点（除根结点外的非终端结点）、叶子（就是终端结点）
	孩子、双亲：每一个树的根节点是根结点直接结点的双亲，直接结点是根结点的孩子
	兄弟：有相同双亲的结点有兄弟关系，统一层级的结点也可以是堂兄弟
	树的结点：树内各结点的度的最大值
	树的深度：树的最大层次
	有序树、无序树			森林（若干无交集的树，一棵树是特殊的森林）

二叉树的定义：每个结点最多只有两个子树。（任意结点的度不大于2）
	二叉树结构最简单，规律性强			每一个树可以唯一转换成一个二叉树
	
二叉树和树是两个概念：有三个结点时，树只有两种结构，而二叉树有5种结构，二叉树中结点的位置是固定的，非左即右，
	而树中，当其他兄弟元素不存在时，结点的位置就没有意义。

案例：（一）数据压缩（对于数据文件转换为0、1的组合）		（二）求解表达式（左子树表示第一个操作数，右子树
	是第二个操作数，根节点的数据域存储运算符号）

二叉树基本操作：1.建立二叉树	2.二叉树遍历（先序遍历、中序遍历、后序遍历）

	二叉树性质：（一）对任意一个二叉树，如果叶子数为n0,度为二的结点数为n2,则n0=n2+1
				计算原理：对n结点的二叉树，总的边数L是n-1，同时L=n2*2+n1（n2表示有两个孩子的结点的个数，
	n1表示有一个孩子的结点的个数），此外总结点数n=n2+n1+n0，联立三个式子得到n0=n2+1。

两种特殊形式的二叉树：
（一）满二叉树：对于深度为k的二叉树，叶子结点必须在最后一层，并且每一层都要满。
（二）完全二叉树：完全二叉树的结点标号都要和层数相同的满二叉树一致，但完全二叉树可以少结点。
	完全二叉树的性质：1.具有n个结点时，完全二叉树的深度为log以2为底n的值取整+1
				    2.完全二叉树中，任意有双亲的结点（编号是i）的编号是[i/2]
				    

二叉树的存储结构：1.顺序存储结构		2.链式（）

1.顺序存储：将任意二叉树按照完全二叉树的形式编号，将不同结点的元素数值存在对应的数组下标位置。
	一般来说，空间浪费很大，所以一般就满二叉树或者完全二叉树才采用这种方式存储。
2.链式存储：（1）二叉链表存储结构 （一个data字段，两个指针域分别指向两个子节点）	
			n个结点的二叉链表，有n+1个空指针域			
		  （2）三叉链表存储结构（多一个指向双亲的指针）。

二叉树的遍历：（每一个元素都只遍历依次）
	遍历方式：
		1.先序遍历（先根后左在右）PreOrderTraverse()	
		2.中序遍历（先左后根再右）MidOrderTraverse()
		3.后序遍历（先左后右再根）LasOrderTraverse()
		显然三种遍历都有递归的思想。
		4.栈思想的非递归遍历
		5.层次遍历（一层一层访问结点，使用队列思想）

	同时知道先序和中序序列或者同时知道后序和中序序列才能够唯一确定二叉树的节点分布。（一定要知道中序序列）


	二叉树遍历的非递归方法：以中序遍历为例
	基本思想：（1）建立一个栈	（2）根结点进栈，遍历左子树	（3）根结点出栈，输出根结点，遍历右子树	

	层次遍历：基本思想：（1）建立一个对列	（2）根结点入队，根结点出队同时将根结点的孩子入队（孩子入队时注意左
					右顺序）	（3）直到没有可入对的孩子后，就将队中元素全部出队即可



线索二叉树：二叉链表中n个结点会有n+1个空指针域，那么就利用这n+1个空指针域来作为线索简化遍历操作，空的左指针域可用于
		存储这个结点的前驱，空的右指针域可以用于存储这个结点的后继，如果只是这么存储的话就无法判断左右指针域到底存			储的是孩子的地址还是前驱或者后继的地址，因此引入ltag、rtag两个标签用于表征记录的数据到底是什么，标签为0，就
		表示指向孩子，如果为1就表示指向前驱或者后继。（前驱后继具体是那个结点是根据二叉树遍历方式确定的，有前序线索		二叉树、中序线索二叉树、后序线索二叉树）


算法实现：1.二叉树的创建	2.二叉树的遍历（5种）	3.二叉树的复制		4.求二叉树的深度	5.求结点总数
		6.计算叶子结点的总数








树和森林：

	树去掉根结点之后可以变成树	
	
	树的存储结构：
		1.双亲表示法，每一个结点的指针域用于存储双亲的地址   （寻找双亲简便）
		2.孩子链表：每一个结点的孩子结点都各自形成一条单链表，每一个结点再存储在一个数组结构中，数组中每个	元素	包含一个数据域和指针域，指针域是该结点孩子链表的头指针。   （找孩子比较方便）（这个方法也可以优化为带双亲的孩子链	表：数组元素的指针域增加一个用于存储双亲地址。（就是双亲表示法））
		3.孩子兄弟表示法（二叉树表示法）：每一个结点包含两个指针域，一个数据域，指针分别指向第一个孩子和下一个兄弟	结点。（也可以增加指针域用于指向双亲）
	
	
		根据二叉树表示法（二叉链表）发现，任意一棵树都可以转化成唯一的二叉链表，然而二叉链表又可以唯一解释成一个对	应的二叉树，因此，我们可以借助媒介二叉链表实现将树转换成二叉树。
		掌握要求：二叉树到树的转换、树到二叉树的转换

	

	森林和二叉树的转换：
		1.先把森林中的每棵树都先转换成二叉树	2.把所有二叉树的根结点相连	3.把第一个二叉树根结点作为最终二叉	树的根结点，将后面的二叉树顺时针旋转45°


	树和森林的遍历：
		1.树的遍历：（一）先根遍历：先遍历根结点再依次遍历子树	（二）后根遍历：先遍历各子树再访问根结点	   （三）层次遍历：若树不为空，则自上而下，自左向右依次遍历每一个结点
		2.森林的遍历：
			森林遍历是将森林看作三个部分：1.是第一棵树的根结点，2.是第一棵树的根的子树森林，3.是森林中除了第一棵以	外的其他树。（一）先序遍历：按照1、2、3的顺序先后遍历森林	（二）中序遍历：按照2、1、3的顺序遍历森林	（三）按照1，3，2的顺序遍历森林




	哈夫曼树及其应用：（最优树：带权路径长度最短的树）
		基本概念：1.路径：哈夫曼树中从树的一个结点到另一个结点的分支		2.路径长度：路径经过的分支的个数
		3.树的路径长度：从树的根结点到所有的结点的路径长度之和（完全二叉树的路径长度是最短的）
		4.权：将树中结点赋予一个有着某种意义的数值		5.结点的带权路径长度：从根结点到该结点的路径长度*权重
		5.树的带权路径长度：根结点到叶子的带权路径长度之和
		（根据树的度不同，又有哈夫曼二叉树、三叉树）
	最优二叉树中，权值越小的离根越远，权值越大的离根越近。哈夫曼树不唯一

	
	哈夫曼树的构造：
		1.构造全是根结点的森林		2.选取权值最小的两棵树构造成一棵新树并把原本的两棵树删除（新树的根结点的权值	就设置为两个小树的权值之和）		3.重复2步骤直到只剩下一棵树		（构造过程中回添加很多新的结点）

	哈夫曼树的特点：1.哈夫曼树的结点的度只能是0或者2		2.有真实权值的结点的在哈夫曼树中都是叶子结点
				3.包含n各叶子结点的哈夫曼树中含有2n-1个结点


	哈夫曼编码：对于字符集想要实现到二进制字符串的编码与可读，并且尽可能简短所需要的编码数。因此：按照概率权重的大小		构建哈夫曼树，然后从根结点开始，左分支编码是0，右分支编码是1，某个字符的编码就是根结点到该结点的分支路径的			编码。哈弗曼编码既是前缀编码（即任意一个的编码都不是其他某个的编码的前缀），而且实现了能够保证编码总长最			短。哈夫曼编码是最优前缀码。


	





算法实现：1.哈夫曼树的构造算法（数据字段有权重，指针域有双亲、左右孩子），采用顺序存储结构。使用一维结构数组，不用	index=0的数组元素，一个n结点的哈夫曼树需要大小为2n的数组。对于元素的删除可以通过将双亲设置为非空表示。
	
	2.算法实现哈夫曼编码：给到要查找的字符，根据这个字符的双亲指针访问双亲并判断该结点是双亲的左还是右孩子，根据左右	添加二进制码的0/1，添加后再从双亲进一步向上寻找，直到找到根结点（双亲为空）就结束，此时就得到了一个倒序二进制编	码，再把返回的编码进行反转就可。


	3.树和森林的遍历

















