栈：  后进先出（Last in first out->LIFO结构）		插入和删除元素都只能对最后一个元素操作

队列：先进先出（First in first out->FIFO结构）		插入只能插入在最后一个元素，删除就是删除第一个元素

	二者都是线性表，但是插入和删除的顺序被限定

1.对于栈：表尾进行数据插入，因此表尾称为栈顶，表头称为栈底。（入栈、出栈）

2.对于队列：插入数据只能在表尾插入，表尾称为队尾，删除数据只能在表头操作，表头称为对头。（入队、出队）

案例：
案例一：进制转换（10->xx）【正向除法取余，反向取余数就是转换结果】
	eg：（159）10->2进制

案例二：括号匹配检测：{[()]}、[(()]检测括号是或否匹配
	实现：将括号序列依次入栈，从第二次入栈开始就将入栈的括号与栈顶匹配，如果左右成对那么就不进栈，并且将
		栈顶括号出栈，依次遍历。

案例三：表达式求值：

案例四：舞伴问题（两个队列，一个存储A，一个存储B，一个A一个B组成一队，A,B长度不同，那么在第一次配对完成后
		短的队列重新入队并于长队列的剩余元素再开始配对）


数据类型定义与基本操作实现：
一.栈
1.InitialStack（&S）初始化空栈S		2.DestoryStack（&S）销毁栈操作	3.StackEmpty（&S）判断是否为空返回bool
4.StackLength（&S）返回栈长度		5.getTop(S,&E)返回栈顶元素		6.clearStack（&S）清空栈
7.Push（&S）压栈，插入元素		8.Pop（&S）出栈
要求再顺序表和链式表中都实现 顺序栈、链栈
（1）顺序栈要设置stacksize来记录栈的最大容量。 此外，对于顺序表，可以用int index发挥指针的作用
	顺序栈的实现可以使用两个指针，一个top，一个base，top指向栈顶元素的下一个位置，base指向栈底，那么top-base
	就等于顺序栈的已存储元素个数，当其值等于stacksize是就表示栈满
（2）链栈不需要头结点，基本不存在栈满的情况；空栈相当于头指针指向空，由于插入和删除都是在栈顶进行的，因此，对
	于链栈，相较于一般的链表，可以将添加的后一个元素的指针域指向他前面的那一个元素，那么每次入栈的时候先将新
	节点的指针域指向栈的头指针，再将头指针指向新的结点。


二.队列
（1）顺序队列：入队时rear（尾指针）就后移，出队时front（头指针）也后移；当rear到了末尾，并且front不是指向第一
	个位置的时候，那么再次入队时就将rear指向首位置，可以使用模运算的方法实现。
	
	判断对空或者对满：可以注意到，当使用模运算的时候实现了特殊的循环，我们可以空出一个元素位置，当front-rear==2
	时就是对满（这种的话front为0要单独考虑）。当front==rear时就是对空。



